# Simulated spindle interface (see spindle.hal)

# counting the spindle encoder in software
loadrt encoder names=encoder_0
# simulate the encoder
loadrt sim_encoder names=sim_encoder_0
loadrt limit2 names=limit_speed

addf limit_speed servo-thread

#######################################################
# Beginning of threading related stuff
#######################################################

# spindle speed control
net spindle-speed-cmd  => limit_speed.in
net spindle-speed-limited limit_speed.out => sim_encoder_0.speed

# simulate spindle mass = acceleration limit
setp limit_speed.maxv 3000.0 # rpm/second^2 acceleration limit

# spindle encoder
# connect encoder signals to encoder counter
net spindle-phase-A sim_encoder_0.phase-A => encoder_0.phase-A
net spindle-phase-B sim_encoder_0.phase-B => encoder_0.phase-B
net spindle-phase-Z sim_encoder_0.phase-Z => encoder_0.phase-Z

# assume 120 ppr = 480 counts/rev for the spindle
setp sim_encoder_0.ppr 12
# iocontrol output is in rpm, but sim-encoder speed is rps
setp sim_encoder_0.scale 60
# scale encoder output to read in revolutions
# (that way thread pitches can be straightforward,
#  a 20 tpi thread would multiply the encoder output
#  by 1/20, etc)
setp encoder_0.position-scale 48

# encoder reset control
# hook up motion controller's sync output
net spindle-index-enable <=> encoder_0.index-enable

# report our revolution count to the motion controller
net spindle-pos <= encoder_0.position
net spindle-rps-raw <= encoder_0.velocity

addf encoder.capture-position servo-thread
addf sim-encoder.update-speed servo-thread

addf sim-encoder.make-pulses    base-thread
addf encoder.update-counters    base-thread

##############################
