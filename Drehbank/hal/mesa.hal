
loadrt hostmot2
# Die folgenden Optionen bestimmen (zusammen mit der geladenen Firmware), welche IOs verfügbar sind; z.T. ermöglichen sie eine Umschaltung des Pin-Typs zwischen Digital-IO und einer Spezialfunktion wie Encoder.
# Siehe auch "man hostmot2" und "man sserial" bzw online unter https://linuxcnc.org/docs/html/man/man9/hostmot2.9.html
# Die Reihenfolge / Zuordnung kann man wie folgt herausfinden:
# 1. Die Zuordnung auf die "Parallelport"-Anschlüsse an der 5i25(=6i25)-Karte steht in der .pin Datei die zur jeweiligen 5i25(=6i25)-Firmware gehört (neu mit Glasmaßstab: 5i25_7i76_7i85.pin) aus /lib/firmware/hm2/5i25 bzw siehe README_Drehbank.md für die Download-URL
# 2. Die Verbindung dieser Anschlüsse mit den tatsächlichen Anschlussklemmen steht im Handbuch der jeweiligen I/O Karte (7i76man.pdf bzw 7i85man.pdf).
# num_encoders=6:
#   encoder.00: an 7i76: Spindel-Encoder
#   encoder.01: (gibt es eigentlich gar nicht; existiert nur aus LinuxCNC-internen Gründen: LinuxCNC muss entweder alle oder keinen Encoder als 2-on-1 Multiplex betreiben. Die 7i76 hat genau einen Encoder. Die 7i85 hat 2x2 Encoder die über eine Select-Leitung umgeschaltet werden. LinuxCNC tut so als hätte die 7i76 2x1 Encoder.)
#   encoder.02: an 7i85 Anschluss ENC 0
#   encoder.03: an 7i85 Anschluss ENC 1
#   encoder.04: an 7i85 Anschluss ENC 2
#   encoder.05: an 7i85 Anschluss ENC 3
# num_stepgens=2:
#   stepgen.00: an 7i76 Anschluss STEP0
#   stepgen.01: an 7i76 Anschluss STEP1
#   (STEP2...4 an 7i76 könnte man durch Erhöhung von num_stepgens aktivieren)
# sserial_port_0: über "smart serial port" (MESA-spezifisches serielles Protokoll) angebundene Expansion-Boards
#   ein Zeichen je internen Ausgabepin (?)
#   (0/1/2 = als smart-serial-port aktiv, in Modus 0/1/2; Modus-Bedeutung je nach Gerät)
#   (x = Pin ist normaler IO-Pin)
#   erste Ziffer = "0": die I/O der 7i76 sind intern über ein solches Protokoll angebunden. ("interner RS485-Port")
#                       Modus 0 = nur Digital-IO, siehe "Software Process Data Modes" in 7i76man.pdf
#   zweite Ziffer = "x": ext. RS485-Port der 7i76 - aktuell deaktiviert; könnte für weiteren IO aktiviert werden
#   übrige Ziffern = "x": ext. RS485 von 7i85 - ungenutzt bzw. als normaler IO-Pin

# ALT:
loadrt hm2_pci config="num_encoders=1 num_pwmgens=0 num_3pwmgens=0 num_stepgens=2 sserial_port_0=00xxx" 
# NEU 7i85: (TODO - neue Firmware laden und hier umstellen)
#loadrt hm2_pci config="num_encoders=6 num_pwmgens=0 num_3pwmgens=0 num_stepgens=4 sserial_port_0=0xxxx" 

setp     hm2_5i25.0.watchdog.timeout_ns 10000000

addf hm2_5i25.0.read servo-thread
addf hm2_5i25.0.write         servo-thread



#######################
# Grundlagen: Bahnplanung GCode etc.

# connect position commands from motion module to step generator
net Xpos-cmd joint.0.motor-pos-cmd => hm2_5i25.0.stepgen.00.position-cmd
net Zpos-cmd joint.1.motor-pos-cmd => hm2_5i25.0.stepgen.01.position-cmd

# connect position feedback from step generators
# to motion module
net Xpos-fb hm2_5i25.0.stepgen.00.position-fb => joint.0.motor-pos-fb
net Zpos-fb hm2_5i25.0.stepgen.01.position-fb => joint.1.motor-pos-fb

net Xen => hm2_5i25.0.stepgen.00.enable
net Zen => hm2_5i25.0.stepgen.01.enable

####################

# set stepgen module scaling - get values from ini file
# zur Angleichung an die simulation auf INPUT_SCALE umbenannt
setp hm2_5i25.0.stepgen.00.position-scale [AXIS_X]INPUT_SCALE
setp hm2_5i25.0.stepgen.01.position-scale [AXIS_Z]INPUT_SCALE

# set stepgen module accel limits - get values from ini file
setp hm2_5i25.0.stepgen.00.maxaccel [AXIS_X]STEPGEN_MAXACCEL
setp hm2_5i25.0.stepgen.01.maxaccel [AXIS_Z]STEPGEN_MAXACCEL

# ergänzt zur Auslagerung in ini-File:
# Timings
setp hm2_5i25.0.stepgen.00.steplen [STEPPER_TIMING]STEPGEN_STEP_LEN
setp hm2_5i25.0.stepgen.00.stepspace [STEPPER_TIMING]STEPGEN_STEP_SPACE
setp hm2_5i25.0.stepgen.00.dirhold [STEPPER_TIMING]STEPGEN_DIR_HOLD
setp hm2_5i25.0.stepgen.00.dirsetup [STEPPER_TIMING]STEPGEN_DIR_SETUP
setp hm2_5i25.0.stepgen.01.steplen [STEPPER_TIMING]STEPGEN_STEP_LEN
setp hm2_5i25.0.stepgen.01.stepspace [STEPPER_TIMING]STEPGEN_STEP_SPACE
setp hm2_5i25.0.stepgen.01.dirhold [STEPPER_TIMING]STEPGEN_DIR_HOLD
setp hm2_5i25.0.stepgen.01.dirsetup [STEPPER_TIMING]STEPGEN_DIR_SETUP



# TB2
# Step/Dir 0 ist Achse X
# Step/Dir 1 ist Achse Z


######################
# Spindel
######################
net spindle-on <= spindle.0.on
net spindle-on => hm2_5i25.0.7i76.0.0.spinena
net spindle-fwd => hm2_5i25.0.7i76.0.0.spindir
# Spindel PWM in 0 ... 1  (1=100%)
# da maxlim und minlim scheinbar kaputt ist, machen wir das vorher selber
setp hm2_5i25.0.7i76.0.0.spinout-scalemax 1
setp hm2_5i25.0.7i76.0.0.spinout-maxlim 1
setp hm2_5i25.0.7i76.0.0.spinout-minlim 0

loadrt scale names=scale_spindle
addf scale_spindle servo-thread
net spindle-speed-cmd-abs <= spindle.0.speed-out-abs
# 5000 rpm = 100%
# 0 rpm = 20% (etwa)
setp scale_spindle.offset 0.2
setp scale_spindle.gain 0.00016
net spindle-speed-cmd-abs => scale_spindle.in
net spindle-pwm-out-unlimited scale_spindle.out 

loadrt limit2 names=limit2_spindle
addf limit2_spindle servo-thread
net spindle-pwm-out-unlimited => limit2_spindle.in
setp limit2_spindle.min 0
# Begrenzung auf 4800 (Futter Maximaldrehzahl) = 0.2 + 0.8*4800/5000
setp limit2_spindle.max 0.968
# Anstieg der Drehzahl begrenzen: 10 Sekunden Hochlaufzeit von 0 auf Maximaldrehzahl ($limit2_spindle.maxv pro Sekunde von 0 bis 1)
setp limit2_spindle.maxv 0.1


# Spindelsignal auf 0% schalten (statt 20% Ruhepegel), wenn ausgeschaltet
loadrt mult2 names=mult2_spindle
addf mult2_spindle servo-thread
net spindle-pwm-always-on limit2_spindle.out => mult2_spindle.in0
net spindle-on-float => mult2_spindle.in1
net spindle-pwm-out mult2_spindle.out => hm2_5i25.0.7i76.0.0.spinout

# bit nach float wandeln
loadrt conv_bit_s32 names=conv_bit_s32-spindle-on
loadrt conv_s32_float names=conv_s32_float-spindle-on
net spindle-on => conv_bit_s32-spindle-on.in
net spindle-on-s32 conv_bit_s32-spindle-on.out => conv_s32_float-spindle-on.in
addf conv_s32_float-spindle-on servo-thread
addf conv_bit_s32-spindle-on servo-thread
net spindle-on-float <= conv_s32_float-spindle-on.out




######################
# Inputs TB5
######################
# In16 Drive 1 Alarm (Fehlermeldung des Steppertreibers)
# weiter unten für estop verwendet
net drive1-alarm <= hm2_5i25.0.7i76.0.0.input-16

# In17 Drive 2 Alarm (Fehlermeldung des Steppertreibers)
# weiter unten für estop verwendet
net drive2-alarm <= hm2_5i25.0.7i76.0.0.input-17

# In18 Notaus
# weiter unten für estop verwendet
net estop-in <= hm2_5i25.0.7i76.0.0.input-18-not

# In19 Futterhaube
net futterhaube-offen <= hm2_5i25.0.7i76.0.0.input-19-not

# In20 Endschalter Z
net Zhomesw <= hm2_5i25.0.7i76.0.0.input-20

# In21 Endschalter X
net Xhomesw <= hm2_5i25.0.7i76.0.0.input-21

# In22 loopback von Out9 (für Watchdog)
net watchdog-loopback-in <= hm2_5i25.0.7i76.0.0.input-22

# In23 Plexi-Schutzhaube
net plexischutzhaube-offen <= hm2_5i25.0.7i76.0.0.input-23-not

# In24-... leer

#############
# Outputs TB5: die Bezeichnung gilt immer für Signal an, also 24V
##############
# Out8 Drive1+2 Enable
# TODO liefert Xen und Zen das gleiche Signal?
# -> or-Gatter o.ä. verbauen
net Xen => hm2_5i25.0.7i76.0.0.output-08
setp hm2_5i25.0.7i76.0.0.output-08-invert true

# Out9 loopback an In22 (für Watchdog)
net watchdog-loopback-out => hm2_5i25.0.7i76.0.0.output-09

# Kühlschmierung an: Nicht von CNC steuerbar, deshalb auskommentiert
# net coolant-flood => ...

# Out11 Schutzhaube freigeben (wenn aus, löst die Schutzhaube den Notaus aus)
net haube-sperren => hm2_5i25.0.7i76.0.0.output-11
setp hm2_5i25.0.7i76.0.0.output-11-invert TRUE

# Out12 Ampel blau
net tool-change => hm2_5i25.0.7i76.0.0.output-12

# Out13 Ampel rot
net estop-out => hm2_5i25.0.7i76.0.0.output-13
setp hm2_5i25.0.7i76.0.0.output-13-invert TRUE

# Out14 Ampel grün
net program-is-running halui.program.is-running => hm2_5i25.0.7i76.0.0.output-14

# Out15 Ampel gelb
net program-is-paused halui.program.is-paused => hm2_5i25.0.7i76.0.0.output-15

# Input TB5
# In0-15 leer

# Outputs TB5
# Out0 Ampel weiß
net futterhaube-oder-plexischutzhaube-offen => hm2_5i25.0.7i76.0.0.output-00 



#######################################################
# Oder-Gatter für "Futterhaube oder Plexischutzhaube offen" zur Ausgabe auf weißer Signalampel
#######################################################
loadrt or2 names=or2_haube_ampel
net futterhaube-oder-plexischutzhaube-offen <= or2_haube_ampel.out
net futterhaube-offen => or2_haube_ampel.in1
net plexischutzhaube-offen => or2_haube_ampel.in2

#######################################################
# Notaus-Überwachung, auch Fehler-Eingänge Drives + Watchdog
#######################################################
loadrt match8 names=match8_errors
addf match8_errors servo-thread
net watchdog-ok => match8_errors.a0
setp match8_errors.b0 TRUE
net drive1-alarm => match8_errors.a1
setp match8_errors.b1 FALSE
net drive2-alarm => match8_errors.a2
setp match8_errors.b2 FALSE
net estop-in => match8_errors.a3
setp match8_errors.b3 FALSE
net futterhaube-fehler => match8_errors.a4
setp match8_errors.b4 FALSE
net encoder-decode-error => match8_errors.a5
setp match8_errors.b5 FALSE

# .a6 bis .a8 wäre noch frei für weitere Dinge...
net estop-out <= match8_errors.out


#######################################################
# Futterhaube sperren gegen spindle-enable
# (-> estop)
#######################################################
loadrt and2 names=and2_futterhaube_fehler
addf and2_futterhaube_fehler servo-thread
net futterhaube-offen => and2_futterhaube_fehler.in0
net spindle-on => and2_futterhaube_fehler.in1
net futterhaube-fehler <= and2_futterhaube_fehler.out

#######################################################
# Watchdog der die IO-Karte überwacht
#######################################################
loadrt not names=not_watchdog
addf not_watchdog servo-thread
net watchdog-loopback-in => not_watchdog.in
net watchdog-loopback-out <= not_watchdog.out

loadrt watchdog num_inputs=1
addf watchdog.process servo-thread
addf watchdog.set-timeouts servo-thread
net watchdog-loopback-in => watchdog.input-0
setp watchdog.enable-in TRUE
setp watchdog.timeout-0 0.01
net watchdog-ok <= watchdog.ok-out



#######################################################
# Logik Freigabe Plexi-Schutzhaube
# Haube sperren, wenn: spindle-on || (program-is-running && !tool-change)
#######################################################
loadrt not names=not_toolchange
addf not_toolchange servo-thread
net tool-change => not_toolchange.in
net tool-change-invert <= not_toolchange.out

loadrt and2 names=and2_programm_bewegt_sich
addf and2_programm_bewegt_sich servo-thread
net program-is-running => and2_programm_bewegt_sich.in0
net tool-change-invert => and2_programm_bewegt_sich.in1
net program-is-running-and-no-toolchange <= and2_programm_bewegt_sich.out

loadrt or2 names=or2_haube_sperren
addf or2_haube_sperren servo-thread

net program-is-running-and-no-toolchange => or2_haube_sperren.in0
net spindle-on => or2_haube_sperren.in1
net haube-sperren <= or2_haube_sperren.out


#######################################################
# Spindle Encoder feedback
#######################################################

# 4000 steps/U
setp hm2_5i25.0.encoder.00.scale 4000
# TODO keine ahnung ob das geht... aber wie will man es testen?
net encoder-decode-error <= hm2_5i25.0.encoder.00.quad-error
setp hm2_5i25.0.encoder.00.quad-error-enable TRUE

# TODO funktioniert gewindedrehen?
# encoder reset control
# hook up motion controller's sync output
net spindle-index-enable <=> hm2_5i25.0.encoder.00.index-enable

# report our revolution count to the motion controller
net spindle-pos <= hm2_5i25.0.encoder.00.position

# for spindle velocity estimate
net spindle-rps-raw <= hm2_5i25.0.encoder.00.velocity 
# further processing see spindle.hal


##################################################
# Axis encoder (open loop!)
# Aktuell nicht in den Feedback-Kreis eingebunden, sondern einfach nur als separate Messvariable
##################################################


### Z

# (auskommentiert = Standardwerte)
# setp    hm2_5i25.0.encoder.02.counter-mode 0
# Hinweis zu Filter: Durch filter=1 wird die maximal mögliche Geschwindigkeit um ca. Faktor 5 reduziert. Dafür werden kurze Störimpulse weggefiltert.
# Max. Verfahrgeschwindigkeit  8 MHz "muxed-sample-frequency" / 2 ((?) wegen Multiplexing) / 200 (Schritte/mm) / 16  (Filterung: 16 bei filter=1, sonst 3) = 1250 mm/s mit Filter.
# Obacht, hier zählt der Spitzenwert, der durch mechanische Schwingungen deutlich höher sein kann als die Soll-Geschwindigkeit (max. 15 mm/s bei CNC).
# setp    hm2_5i25.0.encoder.02.filter 1
# setp    hm2_5i25.0.encoder.02.index-invert 0
# setp    hm2_5i25.0.encoder.02.index-mask 0
# setp    hm2_5i25.0.encoder.02.index-mask-invert 0

setp    hm2_5i25.0.encoder.02.scale  [ENCODER_SCALE]SCALE_Z

net z-pos-measured-raw-mm               <=  hm2_5i25.0.encoder.02.position
net z-vel-measured               <=  hm2_5i25.0.encoder.02.velocity
# net z-index-enable    .....  <=>  hm2_5i25.0.encoder.02.index-enable
net z-pos-measured-rawcounts        <=  hm2_5i25.0.encoder.02.rawcounts

# TODO quad-error-Signal verarbeiten

### TODO: sobald Z funktioniert auch andere Achsen

##############################
